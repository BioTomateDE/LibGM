use crate::{
    gamemaker::{
        data::GMData,
        elements::{functions::GMFunction, game_objects::GMGameObject, variables::GMVariable},
        reference::GMRef,
    },
    gml::instructions::{
        CodeVariable, GMAssetReference, GMCode, GMCodeValue, GMComparisonType, GMDataType,
        GMInstanceType, GMInstruction, GMVariableType,
    },
    prelude::*,
    util::fmt::typename,
};
use std::fmt::Write;

pub fn disassemble_code(code: &GMCode, gm_data: &GMData) -> Result<String> {
    disassemble_instructions(&code.instructions, gm_data)
}

pub fn disassemble_instructions(
    instructions: &[GMInstruction],
    gm_data: &GMData,
) -> Result<String> {
    let mut assembly: String = String::new();

    for instruction in instructions {
        disassemble_instr(instruction, &mut assembly, gm_data)?;
        assembly.push('\n');
    }

    Ok(assembly)
}

pub fn disassemble_instruction(instruction: &GMInstruction, gm_data: &GMData) -> Result<String> {
    let mut string = String::new();
    disassemble_instr(instruction, &mut string, gm_data)?;
    Ok(string)
}

fn disassemble_instr(
    instruction: &GMInstruction,
    string: &mut String,
    gm_data: &GMData,
) -> Result<()> {
    let opcode: &str = opcode_to_string(instruction);

    match instruction {
        GMInstruction::Exit
        | GMInstruction::Return
        | GMInstruction::PopSwap { .. }
        | GMInstruction::PopWithContextExit
        | GMInstruction::CheckArrayIndex
        | GMInstruction::PushArrayFinal
        | GMInstruction::PopArrayFinal
        | GMInstruction::PushArrayContainer
        | GMInstruction::SetArrayOwner
        | GMInstruction::HasStaticInitialized
        | GMInstruction::SetStaticInitialized
        | GMInstruction::SaveArrayReference
        | GMInstruction::RestoreArrayReference
        | GMInstruction::IsNullishValue => {
            write!(string, "{opcode}");
        },

        GMInstruction::Negate { data_type }
        | GMInstruction::Not { data_type }
        | GMInstruction::PopDiscard { data_type } => {
            write!(string, "{}.{}", opcode, data_type.to_str());
        },

        GMInstruction::CallVariable { argument_count } => {
            write!(string, "{opcode} {argument_count}");
        },

        GMInstruction::Duplicate { data_type, size } => {
            write!(string, "{}.{} {}", opcode, data_type.to_str(), size,);
        },

        GMInstruction::DuplicateSwap { data_type, size1, size2 } => {
            write!(
                string,
                "{}.{} {} {}",
                opcode,
                data_type.to_str(),
                size1,
                size2,
            );
        },

        GMInstruction::Branch { jump_offset }
        | GMInstruction::BranchIf { jump_offset }
        | GMInstruction::BranchUnless { jump_offset }
        | GMInstruction::PushWithContext { jump_offset }
        | GMInstruction::PopWithContext { jump_offset } => {
            write!(string, "{opcode} {jump_offset}");
        },

        GMInstruction::Convert { from: type1, to: type2 }
        | GMInstruction::Multiply { multiplicand: type2, multiplier: type1 }
        | GMInstruction::Divide { dividend: type2, divisor: type1 }
        | GMInstruction::Remainder { dividend: type2, divisor: type1 }
        | GMInstruction::Modulus { dividend: type2, divisor: type1 }
        | GMInstruction::Add { augend: type2, addend: type1 }
        | GMInstruction::Subtract { minuend: type2, subtrahend: type1 }
        | GMInstruction::And { lhs: type2, rhs: type1 }
        | GMInstruction::Or { lhs: type2, rhs: type1 }
        | GMInstruction::Xor { lhs: type2, rhs: type1 }
        | GMInstruction::ShiftLeft { value: type2, shift_amount: type1 }
        | GMInstruction::ShiftRight { value: type2, shift_amount: type1 } => {
            write!(string, "{}.{}.{}", opcode, type1.to_str(), type2.to_str());
        },

        GMInstruction::Compare { lhs, rhs, comparison_type } => {
            write!(
                string,
                "{}.{}.{} {}",
                opcode,
                rhs.to_str(),
                lhs.to_str(),
                comparison_type.to_str(),
            );
        },

        GMInstruction::Pop { variable, type1, type2 } => {
            // TODO: find the instance type of the variable
            write!(string, "{}.{}.{} ", opcode, type1.to_str(), type2.to_str());
            write_variable(variable, string, gm_data)?;
        },

        GMInstruction::Push { value } => {
            write!(string, "{}.{} ", opcode, value.data_type().to_str());

            match value {
                GMCodeValue::Variable(code_variable) => {
                    write_variable(code_variable, string, gm_data)?;
                },
                GMCodeValue::Boolean(true) => {
                    write!(string, "true");
                },
                GMCodeValue::Boolean(false) => {
                    write!(string, "false");
                },
                GMCodeValue::Function(function_ref) => {
                    write!(
                        string,
                        "(function){}",
                        resolve_function_name(*function_ref, gm_data)?
                    );
                }, // TODO  rename  string
                GMCodeValue::String(string2) => write_literal_string(string2, string),
                GMCodeValue::Int16(integer) => {
                    write!(string, "{integer}");
                },
                GMCodeValue::Int32(integer) => {
                    write!(string, "{integer}");
                },
                GMCodeValue::Int64(integer) => {
                    write!(string, "{integer}");
                },
                GMCodeValue::Double(float) => {
                    write!(string, "{float}");
                },
            }
        },
        GMInstruction::PushLocal { variable }
        | GMInstruction::PushGlobal { variable }
        | GMInstruction::PushBuiltin { variable } => {
            write!(string, "{} {}", opcode, write_variable(variable)?)
        },

        GMInstruction::PushImmediate { integer } => {
            write!(string, "{opcode} {integer}")
        },

        &GMInstruction::Call { function, argument_count } => {
            write!(
                string,
                "{} {}(argc={})",
                opcode,
                resolve_function_name(function, gm_data)?,
                argument_count,
            )
        },

        GMInstruction::PushReference { asset_reference } => {
            write!(
                string,
                "{} {}",
                opcode,
                write_asset_reference(asset_reference, string, gm_data)?,
            )
        },
    };

    Ok(line)
}

impl GMInstruction {
    #[must_use]
    const fn mnemonic(&self) -> &'static str {
        match self {
            Self::Convert { .. } => "conv",
            Self::Multiply { .. } => "mul",
            Self::Divide { .. } => "div",
            Self::Remainder { .. } => "rem",
            Self::Modulus { .. } => "mod",
            Self::Add { .. } => "add",
            Self::Subtract { .. } => "sub",
            Self::And { .. } => "and",
            Self::Or { .. } => "or",
            Self::Xor { .. } => "xor",
            Self::Negate { .. } => "neg",
            Self::Not { .. } => "not",
            Self::ShiftLeft { .. } => "shl",
            Self::ShiftRight { .. } => "shr",
            Self::Compare { .. } => "cmp",
            Self::Pop { .. } => "pop",
            Self::PopSwap { is_array: false } => "popswap",
            Self::PopSwap { is_array: true } => "popswaparr",
            Self::Duplicate { .. } => "dup",
            Self::DuplicateSwap { .. } => "dupswap",
            Self::Return => "ret",
            Self::Exit => "exit",
            Self::PopDiscard { .. } => "popz",
            Self::Branch { .. } => "jmp",
            Self::BranchIf { .. } => "jt",
            Self::BranchUnless { .. } => "jf",
            Self::PushWithContext { .. } => "pushenv",
            Self::PopWithContext { .. } => "popenv",
            Self::PopWithContextExit => "popenvexit",
            Self::Push { .. } => "push",
            Self::PushLocal { .. } => "pushloc",
            Self::PushGlobal { .. } => "pushglb",
            Self::PushBuiltin { .. } => "pushbltn",
            Self::PushImmediate { .. } => "pushim",
            Self::Call { .. } => "call",
            Self::CallVariable { .. } => "callvar",
            Self::CheckArrayIndex => "chkindex",
            Self::PushArrayFinal => "pushaf",
            Self::PopArrayFinal => "popaf",
            Self::PushArrayContainer => "pushac",
            Self::SetArrayOwner => "setowner",
            Self::HasStaticInitialized => "isstaticok",
            Self::SetStaticInitialized => "setstatic",
            Self::SaveArrayReference => "savearef",
            Self::RestoreArrayReference => "restorearef",
            Self::IsNullishValue => "isnullish",
            Self::PushReference { .. } => "pushref",
        }
    }
}

impl GMDataType {
    #[must_use]
    const fn to_str(self) -> &'static str {
        match self {
            Self::Int16 => "e",
            Self::Int32 => "i",
            Self::Int64 => "l",
            Self::Double => "d",
            Self::Boolean => "b",
            Self::String => "s",
            Self::Variable => "v",
        }
    }
}

impl GMComparisonType {
    #[must_use]
    const fn to_str(self) -> &'static str {
        match self {
            Self::LessThan => "LT",
            Self::LessOrEqual => "LTE",
            Self::Equal => "EQ",
            Self::NotEqual => "NEQ",
            Self::GreaterOrEqual => "GTE",
            Self::GreaterThan => "GT",
        }
    }
}

impl GMVariableType {
    #[must_use]
    const fn to_str(self) -> &'static str {
        match self {
            Self::Normal | Self::Instance => "",
            Self::Array => "[array]",
            Self::StackTop => "[stacktop]",
            Self::ArrayPushAF => "[arraypushaf]",
            Self::ArrayPopAF => "[arraypopaf]",
        }
    }
}

#[inline]
fn asset_get_name<T>(
    gm_elements: &Vec<T>,
    gm_ref: GMRef<T>,
    get_name: impl FnOnce(&T) -> &String,
) -> Result<&String> {
    let element: &T = gm_ref
        .resolve(gm_elements)
        .context("resolving asset reference for PushReference Instruction")?;

    let name: &String = get_name(element);

    if !is_valid_identifier(name) {
        bail!("Invalid {} identifier: {:?}", typename::<T>(), name)
    }
    Ok(name)
}

fn write_asset_reference(
    asset_ref: &GMAssetReference,
    string: &mut String,
    gm_data: &GMData,
) -> Result<()> {
    match asset_ref {
        &GMAssetReference::Object(gm_ref) => {
            write!(
                string,
                "(object){}",
                asset_get_name(&gm_data.game_objects, gm_ref, |x| &x.name)?
            );
        },
        &GMAssetReference::Sprite(gm_ref) => {
            write!(
                string,
                "(sprite){}",
                asset_get_name(&gm_data.sprites, gm_ref, |x| &x.name)?
            );
        },
        &GMAssetReference::Sound(gm_ref) => {
            write!(
                string,
                "(sound){}",
                asset_get_name(&gm_data.sounds, gm_ref, |x| &x.name)?
            );
        },
        &GMAssetReference::Room(gm_ref) => {
            write!(
                string,
                "(sprite){}",
                asset_get_name(&gm_data.rooms, gm_ref, |x| &x.name)?
            );
        },
        &GMAssetReference::Background(gm_ref) => {
            write!(
                string,
                "(background){}",
                asset_get_name(&gm_data.backgrounds, gm_ref, |x| &x.name)?
            );
        },
        &GMAssetReference::Path(gm_ref) => {
            write!(
                string,
                "(path){}",
                asset_get_name(&gm_data.paths, gm_ref, |x| &x.name)?
            );
        },
        &GMAssetReference::Script(gm_ref) => {
            write!(
                string,
                "(script){}",
                asset_get_name(&gm_data.scripts, gm_ref, |x| &x.name)?
            );
        },
        &GMAssetReference::Font(gm_ref) => {
            write!(
                string,
                "(font){}",
                asset_get_name(&gm_data.fonts, gm_ref, |x| &x.name)?
            );
        },
        &GMAssetReference::Timeline(gm_ref) => {
            write!(
                string,
                "(timeline){}",
                asset_get_name(&gm_data.timelines, gm_ref, |x| &x.name)?
            );
        },
        &GMAssetReference::Shader(gm_ref) => {
            write!(
                string,
                "(shader){}",
                asset_get_name(&gm_data.shaders, gm_ref, |x| &x.name)?
            );
        },
        &GMAssetReference::Sequence(gm_ref) => {
            write!(
                string,
                "(sequence){}",
                asset_get_name(&gm_data.sequences, gm_ref, |x| &x.name)?
            );
        },
        &GMAssetReference::AnimCurve(gm_ref) => {
            write!(
                string,
                "(animcurve){}",
                asset_get_name(&gm_data.animation_curves, gm_ref, |x| &x.name)?
            );
        },
        &GMAssetReference::ParticleSystem(gm_ref) => {
            write!(
                string,
                "(particlesys){}",
                asset_get_name(&gm_data.particle_systems, gm_ref, |x| &x.name)?
            );
        },
        &GMAssetReference::RoomInstance(id) => {
            write!(string, "(roominstance){id}");
        },
        &GMAssetReference::Function(gm_ref) => {
            write!(
                string,
                "(function){}",
                resolve_function_name(gm_ref, gm_data)?
            );
        },
    }

    Ok(())
}

fn write_instance_type(
    instance_type: GMInstanceType,
    string: &mut String,
    variable_ref: GMRef<GMVariable>,
    gm_data: &GMData,
) -> Result<()> {
    match instance_type {
        GMInstanceType::Undefined => {
            unreachable!("Did not expect Instance Type Undefined here; please report this error")
        },
        GMInstanceType::Self_(Some(obj_ref)) => {
            let obj: &GMGameObject = obj_ref.resolve(&gm_data.game_objects)?;
            write!(string, "self<{}>", obj.name)
        },
        GMInstanceType::Self_(None) => write!(string, "self"),
        GMInstanceType::RoomInstance(instance_id) => {
            write!(string, "roominstance<{instance_id}>")
        },
        GMInstanceType::Other => write!(string, "other"),
        GMInstanceType::All => write!(string, "all"),
        GMInstanceType::None => write!(string, "none"),
        GMInstanceType::Global => write!(string, "global"),
        GMInstanceType::Builtin => write!(string, "builtin"),
        GMInstanceType::Local => write!(string, "local<{}>", variable_ref.index),
        GMInstanceType::StackTop => write!(string, "stacktop"),
        GMInstanceType::Argument => write!(string, "arg"),
        GMInstanceType::Static => write!(string, "static"),
    };

    Ok(())
}

fn write_variable(
    code_variable: &CodeVariable,
    string: &mut String,
    gm_data: &GMData,
) -> Result<()> {
    let variable: &GMVariable = code_variable.variable.resolve(&gm_data.variables)?;
    let name = &variable.name;

    if !is_valid_identifier(name) && name != "$$$$temp$$$$" {
        bail!("Invalid variable identifier {name:?}");
    }

    if code_variable.is_int32 {
        write!(string, "(variable)");
    }

    write!(string, "{}", code_variable.variable_type.to_str());

    let instance_type: GMInstanceType = if code_variable.instance_type == GMInstanceType::Undefined
    {
        // TODO: this will not work with b14
        variable
            .b15_data
            .as_ref()
            .map_or(GMInstanceType::Undefined, |b15| b15.instance_type)
    } else {
        code_variable.instance_type
    };

    write_instance_type(instance_type, string, code_variable.variable, gm_data)?;
    write!(string, ".{name}");

    Ok(())
}

fn resolve_function_name(function_ref: GMRef<GMFunction>, gm_data: &GMData) -> Result<&String> {
    let function: &GMFunction = function_ref.resolve(&gm_data.functions)?;
    let name = &function.name;
    if !is_valid_identifier(name) {
        let is_special = name.starts_with("@@")
            && name.ends_with("@@")
            && is_valid_identifier(&name[2..name.len() - 2]);

        if !is_special {
            bail!("Invalid function identifier: {name:?}");
        }
    }
    Ok(name)
}

fn write_literal_string(string_lit: &str, buffer: &mut String) {
    // Fast path: check if any escaping is needed
    if !string_lit
        .bytes()
        .any(|b| matches!(b, b'\\' | b'"' | b'\n' | b'\r' | b'\t'))
    {
        write!(buffer, "\"{string_lit}\"");
        return;
    }

    // Slow path: escaping needed
    // Estimate capacity: original length + 2 quotes + some overhead for escapes
    buffer.reserve(string_lit.len() + string_lit.len() / 4 + 2);
    buffer.push('"');

    for c in string_lit.chars() {
        match c {
            '\\' => buffer.push_str("\\\\"),
            '"' => buffer.push_str("\\\""),
            '\n' => buffer.push_str("\\n"),
            '\r' => buffer.push_str("\\r"),
            '\t' => buffer.push_str("\\t"),
            _ => buffer.push(c),
        }
    }

    buffer.push('"');
}

/// Check whether an identifier / asset name is valid for assembling properly.
/// Exceptions like `$$$$temp$$$$` for variables or `@@This@@` for functions will have to be handled separately.
/// ## Rules:
/// - At least one character long
/// - First character is not a digit
/// - Letters and underscores are allowed
/// - Only ascii characters
fn is_valid_identifier(s: &str) -> bool {
    let mut chars = s.chars();
    chars
        .next()
        .is_some_and(|c| c.is_ascii_alphabetic() || c == '_')
        && chars.all(|c| c.is_ascii_alphanumeric() || c == '_')
}
